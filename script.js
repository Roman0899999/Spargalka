let output = document.querySelector('.output') 
 
 
function funcPromise(){ 
    output.innerHTML = ` <h5> 1. Promise (Обещание)</h5> <br> 
    Promise - это объект, представляющий асинхронную операцию, которая может завершиться успешно (resolve) или с ошибкой (reject). Промисы позволяют более четко и удобно управлять асинхронным кодом. 
  
    Пример создания промиса:<br> 
    <pre> 
    const myPromise = new Promise((resolve, reject) => { 
      // Асинхронный код, который может завершиться успешно или с ошибкой 
      if (/* условие */) { 
        resolve('Успех!'); // В случае успешного выполнения 
      } else { 
        reject('Ошибка!'); // В случае ошибки 
      } 
    }); 
   </pre> 
 <h5> 2. async и await:</h5> 
    async и await - это синтаксический сахар для работы с промисами, который делает асинхронный код более читаемым и удобным. 
  
    Пример использования async и await:<br> 
    <pre> 
    async function fetchData() { 
      try { 
        const response = await fetch('https://dummyjson.com/products'); 
        const data = await response.json(); 
        return data; 
      } catch (error) { 
        console.error('Ошибка:', error); 
      } 
    } 
    </pre> 
    
    <h5>3. Практические примеры:</h5> 
  
    Пример 1: Загрузка данных с сервера с использованием async/await: 
    <pre> 
    async function fetchData() { 
      try { 
        const response = await fetch('url'); 
        const data = await response.json(); 
        return data; 
      } catch (error) { 
        console.error('Ошибка:', error); 
      } 
    } 
    </pre> 
    Пример 2: Параллельное выполнение нескольких асинхронных операций с Promise.all: 
    async function fetchMultipleData() { 
      const promises = [fetchData1(), fetchData2(), fetchData3()]; 
      const data = await Promise.all(promises); 
      return data; 
    } 
   
    Пример 3: Цепочка обработки данных с промисами: 
    fetch(url) 
      .then(data => data.json()) 
      .then(json => console.log(json)) 
      .catch(error => console.log(error));` 
} 
 
function funcClass(){ 
  output.innerHTML = `Базовый синтаксис выглядит так: <br>
  <pre>
  class MyClass {
    // методы класса
    constructor() { ... }
    method1() { ... }
    method2() { ... }
    method3() { ... }
    ...
  }
  </pre> <br>
  Затем используйте вызов new MyClass() для создания нового объекта со всеми перечисленными методами.<br>
  
  При этом автоматически вызывается метод constructor(), в нём мы можем инициализировать объект.<br>
  
  Например:<br>
  <pre>
  class User {
  
    constructor(name) {
      this.name = name;
    }
  
    sayHi() {
      alert(this.name);
    }
  
  }
  </pre> <br>
  <pre>
  // Использование:
  let user = new User("Иван");
  user.sayHi();
  Когда вызывается new User("Иван"):
  </pre><br>
  Создаётся новый объект.<br>
  constructor запускается с заданным аргументом и сохраняет его в this.name.<br>
  …Затем можно вызывать на объекте методы, такие как user.sayHi().<br>
  
  Методы в классе не разделяются запятой<br>
  Частая ошибка начинающих разработчиков – ставить запятую между методами класса, что приводит к синтаксической ошибке.<br>
  
  Синтаксис классов отличается от литералов объектов, не путайте их. Внутри классов запятые не требуются.<br>
  
  Что такое класс?<br>
  Итак, что же такое class? Это не полностью новая языковая сущность, как может показаться на первый взгляд.<br>
  
  Давайте развеем всю магию и посмотрим, что такое класс на самом деле. Это поможет в понимании многих сложных аспектов.<br>
  
  В JavaScript класс – это разновидность функции.<br>
  
  Взгляните:<br>
  <pre>
  class User {
    constructor(name) { this.name = name; }
    sayHi() { alert(this.name); }
  }
  
  // доказательство: User - это функция
  alert(typeof User); // function
  Вот что на самом деле делает конструкция class User {...}:
  </pre><br>
  Создаёт функцию с именем User, которая становится результатом объявления класса. Код функции берётся из метода constructor (она будет пустой, если такого метода нет).
  Сохраняет все методы, такие как sayHi, в User.prototype.
  При вызове метода объекта new User он будет взят из прототипа, как описано в главе F.prototype. Таким образом, объекты new User имеют доступ к методам класса.
  <br>
  На картинке показан результат объявления class User:
  <br>
  
  Можно проверить вышесказанное и при помощи кода:<br>
  <pre>
  class User {
    constructor(name) { this.name = name; }
    sayHi() { alert(this.name); }
  }
  
  // класс - это функция
  alert(typeof User); // function
  
  // ...или, если точнее, это метод constructor
  alert(User === User.prototype.constructor); // true
  
  // Методы находятся в User.prototype, например:
  alert(User.prototype.sayHi); // sayHi() { alert(this.name); }
  
  // в прототипе ровно 2 метода
  alert(Object.getOwnPropertyNames(User.prototype)); // constructor, sayHi
  Не просто синтаксический сахар
  Иногда говорят, что class – это просто «синтаксический сахар» в JavaScript (синтаксис для улучшения читаемости кода, <br>
    но не делающий ничего принципиально нового), потому что мы можем сделать всё то же самое без конструкции class:
  
  // перепишем класс User на чистых функциях
  
  // 1. Создаём функцию constructor
  function User(name) {
    this.name = name;
  }
  // каждый прототип функции имеет свойство constructor по умолчанию,
  // поэтому нам нет необходимости его создавать
  
  // 2. Добавляем метод в прототип
  User.prototype.sayHi = function() {
    alert(this.name);
  };
  
  // Использование:
  let user = new User("Иван");
  user.sayHi();</pre> <br>
  Результат этого кода очень похож. Поэтому, действительно, есть причины, по которым class можно считать синтаксическим сахаром для определения конструктора вместе с методами прототипа.
  <br>
  Однако есть важные отличия:
  <br>
  Во-первых, функция, созданная с помощью class, помечена специальным внутренним свойством [[IsClassConstructor]]: true. Поэтому это не совсем то же самое, что создавать её вручную.
  <br>
  В отличие от обычных функций, конструктор класса не может быть вызван без new:
  <pre> 
  class User {
    constructor() {}
  }
  
  alert(typeof User); // function
  User(); // Error: Class constructor User cannot be invoked without 'new'
  Кроме того, строковое представление конструктора класса в большинстве движков JavaScript начинается с «class …»
  
  class User {
    constructor() {}
  }<br>
  
  alert(User); // class User { ... }<br>
  </pre><br>
  Методы класса являются неперечислимыми. Определение класса устанавливает флаг enumerable в false для всех методов в "prototype".
  <br>
  И это хорошо, так как если мы проходимся циклом for..in по объекту, то обычно мы не хотим при этом получать методы класса.
  <br>
  Классы всегда используют use strict. Весь код внутри класса автоматически находится в строгом режиме.
  <br>
  Также в дополнение к основной, описанной выше, функциональности, синтаксис class даёт ряд других интересных возможностей, с которыми мы познакомимся чуть позже.
  <br>
  <h1>Class Expression</h1><br>
  Как и функции, классы можно определять внутри другого выражения, передавать, возвращать, присваивать и т.д.<br>
  
  Пример Class Expression (по аналогии с Function Expression):<br>
  <pre>
  
  let User = class {
    sayHi() {
      alert("Привет");
    }
  };
  </pre><br>
  Аналогично Named Function Expression, Class Expression может иметь имя.<br>
  
  Если у Class Expression есть имя, то оно видно только внутри класса:<br>
  <pre>
  
  // "Named Class Expression"
  // (в спецификации нет такого термина, но происходящее похоже на Named Function Expression)
  let User = class MyClass {
    sayHi() {
      alert(MyClass); // имя MyClass видно только внутри класса
    }
  };
  
  new User().sayHi(); // работает, выводит определение MyClass
  
  alert(MyClass); // ошибка, имя MyClass не видно за пределами класса 
  </pre><br>
  Мы даже можем динамически создавать классы «по запросу»:<br>
  <pre>
  function makeClass(phrase) {
    // объявляем класс и возвращаем его
    return class {
      sayHi() {
        alert(phrase);
      };
    };
  }
  
  // Создаём новый класс
  let User = makeClass("Привет");
  
  new User().sayHi(); // Привет</pre><br>
  Геттеры/сеттеры, другие сокращения<br>
  Как и в литеральных объектах, в классах можно объявлять вычисляемые свойства, геттеры/сеттеры и т.д.<br>
  
  Вот пример user.name, реализованного с использованием get/set:<br>
  <pre>
  
  class User {
  
    constructor(name) {
      // вызывает сеттер
      this.name = name;
    }
  
    get name() {
      return this._name;
    }
  
    set name(value) {
      if (value.length < 4) {
        alert("Имя слишком короткое.");
        return;
      }
      this._name = value;
    }
  
  }
  
  let user = new User("Иван");
  alert(user.name); // Иван
  
  user = new User(""); // Имя слишком короткое.</pre><br>
  При объявлении класса геттеры/сеттеры создаются на User.prototype, вот так:<br>
  <pre>
  
  Object.defineProperties(User.prototype, {
    name: {
      get() {
        return this._name
      },
      set(name) {
        // ...
      }
    }
  });
  Пример с вычисляемым свойством в скобках [...]:
  
  class User {
  
    ['say' + 'Hi']() {
      alert("Привет");
    }
  
  }
  
  new User().sayHi();
  </pre><br>
  Свойства классов<br>
  Старым браузерам может понадобиться полифил<br>
  Свойства классов добавлены в язык недавно.<br>
  
  В приведённом выше примере у класса User были только методы. Давайте добавим свойство:<br>
  <pre>
  
  class User {
    name = "Аноним";
  
    sayHi() {
      alert(Привет, ${this.name}!);
    }
  }
  
  new User().sayHi();
  </pre><br>
  Свойство name не устанавливается в User.prototype. Вместо этого оно создаётся оператором new перед запуском конструктора, это именно свойство объекта.
  
  <h3>Итого
  Базовый синтаксис для классов выглядит так:</h3><br>
  <pre>
  
  class MyClass {
    prop = value; // свойство
    constructor(...) { // конструктор
      // ...
    }
    method(...) {} // метод
    get something(...) {} // геттер
    set something(...) {} // сеттер
    [Symbol.iterator]() {} // метод с вычисляемым именем (здесь - символом)
    // ...
  }
  </pre><br>
  MyClass технически является функцией (той, которую мы определяем как constructor), в то время как методы, геттеры и сеттеры записываются в MyClass.prototype.
  <br>
  В следующих главах мы узнаем больше о классах, включая наследование и другие возможности.`
 
} 
 
function funcCallB(){ 
  output.innerHTML = `<h1>Введение: колбэки</h1><br>
  Многие действия в JavaScript асинхронные.<br>

Например, рассмотрим функцию loadScript(src):<br>
<pre>function loadScript(src) {
  let script = document.createElement('script');
  script.src = src;
  document.head.append(script);
}
</pre><br>
Эта функция загружает на страницу новый скрипт. Когда в тело документа добавится конструкция script src="…", браузер загрузит скрипт и выполнит его.

Вот пример использования этой функции:
<br><pre>
// загрузит и выполнит скрипт
loadScript('/my/script.js');</pre><br>
Такие функции называют «асинхронными», потому что действие (загрузка скрипта) будет завершено не сейчас, а потом.<br>

Если после вызова loadScript(…) есть какой-то код, то он не будет ждать, пока скрипт загрузится.<br>
<pre>

loadScript('/my/script.js');
// код, написанный после вызова функции loadScript,
// не будет дожидаться полной загрузки скрипта
// ...
</pre><br>
Мы хотели бы использовать новый скрипт, как только он будет загружен. Скажем, он объявляет новую функцию, которую мы хотим выполнить.
<br>
Но если мы просто вызовем эту функцию после loadScript(…), у нас ничего не выйдет:<br>
<pre>
loadScript('/my/script.js'); // в скрипте есть "function newFunction() {…}"

newFunction(); // такой функции не существует!</pre><br>
Действительно, ведь у браузера не было времени загрузить скрипт. Сейчас функция loadScript никак не позволяет отследить момент загрузки. Скрипт загружается, а потом выполняется. Но нам нужно точно знать, когда это произойдёт, чтобы использовать функции и переменные из этого скрипта.
<br>
Давайте передадим функцию callback вторым аргументом в loadScript, чтобы вызвать её, когда скрипт загрузится:
<br><pre>
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;
  script.onload = () => callback(script);
  document.head.append(script);
}</pre><br>
Событие onload описано в статье Загрузка ресурсов: onload и onerror, оно в основном выполняет функцию после загрузки и выполнения скрипта.
<br>
Теперь, если мы хотим вызвать функцию из скрипта, нужно делать это в колбэке:
<br><pre>
loadScript('/my/script.js', function() {
  // эта функция вызовется после того, как загрузится скрипт
  newFunction(); // теперь всё работает
  ...
});
</pre><br>
Смысл такой: вторым аргументом передаётся функция (обычно анонимная), которая выполняется по завершении действия.
<br>
Возьмём для примера реальный скрипт с библиотекой функций:<br>
<pre>
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;
  script.onload = () => callback(script);
  document.head.append(script);
}

loadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', script => {
  alert(Здорово, скрипт загрузился);
  alert( _ ); // функция, объявленная в загруженном скрипте
});</pre><br>
Такое написание называют асинхронным программированием с использованием колбэков. В функции, которые выполняют какие-либо асинхронные операции, передаётся аргумент callback — функция, которая будет вызвана по завершению асинхронного действия.
<br>
Мы поступили похожим образом в loadScript, но это, конечно, распространённый подход.<br>
<h1>Колбэк в колбэке</h1><br>
Как нам загрузить два скрипта один за другим: сначала первый, а за ним второй?<br>

Первое, что приходит в голову, вызвать loadScript ещё раз уже внутри колбэка, вот так:<br>
<pre>
loadScript('/my/script.js', function(script) {

  alert(Здорово, скрипт  загрузился, загрузим ещё один);

  loadScript('/my/script2.js', function(script) {
    alert(Здорово, второй скрипт загрузился);
  });

});</pre><br>
Когда внешняя функция loadScript выполнится, вызовется та, что внутри колбэка.<br>

А что если нам нужно загрузить ещё один скрипт?..<br>
<pre>
loadScript('/my/script.js', function(script) {

  loadScript('/my/script2.js', function(script) {

    loadScript('/my/script3.js', function(script) {
      // ...и так далее, пока все скрипты не будут загружены
    });

  })

});</pre><br>
Каждое новое действие мы вынуждены вызывать внутри колбэка. Этот вариант подойдёт, когда у нас одно-два действия, но для большего количества уже не удобно. Альтернативные подходы мы скоро разберём.<br>
<h1>Перехват ошибок</h1><br>
В примерах выше мы не думали об ошибках. А что если загрузить скрипт не удалось? Колбэк должен уметь реагировать на возможные проблемы.
<br>
Ниже улучшенная версия loadScript, которая умеет отслеживать ошибки загрузки:<br>
<pre>

function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(null, script);
  

  document.head.append(script);
}</pre><br>
Мы вызываем callback(null, script) в случае успешной загрузки и callback(error), если загрузить скрипт не удалось.
<br>
Живой пример:<br>
<pre>
loadScript('/my/script.js', function(error, script) {
  if (error) {
    // обрабатываем ошибку
  } else {
    // скрипт успешно загружен
  }
});
</pre><br>
Опять же, подход, который мы использовали в loadScript, также распространён и называется «колбэк с первым аргументом-ошибкой» («error-first callback»).
<br>
Правила таковы:<br>

Первый аргумент функции callback зарезервирован для ошибки. В этом случае вызов выглядит вот так: callback(err).<br>
Второй и последующие аргументы — для результатов выполнения. В этом случае вызов выглядит вот так: callback(null, result1, result2…).<br>
Одна и та же функция callback используется и для информирования об ошибке, и для передачи результатов.

`

} 
 
function funcArr(){ 
  output.innerHTML =`<h1>Массивы</h1><br>
  Объекты позволяют хранить данные со строковыми ключами. Это замечательно.<br><br>
  
  Но довольно часто мы понимаем, что нам необходима упорядоченная коллекция данных, в которой присутствуют 1-й, 2-й, 3-й элементы и т.д. Например, она понадобится нам для хранения списка чего-либо: пользователей, товаров, элементов HTML и т.д.
  <br><br>
  В этом случае использовать объект неудобно, так как он не предоставляет методов управления порядком элементов. Мы не можем вставить новое свойство «между» уже существующими. Объекты просто не предназначены для этих целей.
  <br><br>
  Для хранения упорядоченных коллекций существует особая структура данных, которая называется массив, Array.
  Объявление<br><br>
Существует два варианта синтаксиса для создания пустого массива:<br>
<pre>

let arr = new Array();
let arr = [];
</pre><br>
Практически всегда используется второй вариант синтаксиса. В скобках мы можем указать начальные значения элементов:
<br>
<pre>
let fruits = ["Яблоко", "Апельсин", "Слива"];
</pre><br>
Элементы массива нумеруются, начиная с нуля.<br>

Мы можем получить элемент, указав его номер в квадратных скобках:<br>
<pre>
let fruits = ["Яблоко", "Апельсин", "Слива"];

alert( fruits[0] ); // Яблоко
alert( fruits[1] ); // Апельсин
alert( fruits[2] ); // Слива
</pre><br>
Мы можем заменить элемент:<br>
<pre>
fruits[2] = 'Груша'; // теперь ["Яблоко", "Апельсин", "Груша"]</pre><br>
…Или добавить новый к существующему массиву:<br>
<pre>
fruits[3] = 'Лимон'; // теперь ["Яблоко", "Апельсин", "Груша", "Лимон"]
</pre><br>
Общее число элементов массива содержится в его свойстве length:<br>
<pre>
let fruits = ["Яблоко", "Апельсин", "Слива"];

alert( fruits.length ); // 3
</pre><br>
Вывести массив целиком можно при помощи alert.<br>
<pre>
let fruits = ["Яблоко", "Апельсин", "Слива"];

alert( fruits ); // Яблоко, Апельсин, Слива
</pre><br>
В массиве могут храниться элементы любого типа.<br>

Например:<br><br>
<pre>
// разные типы значений
let arr = [ 'Яблоко', { name: 'Джон' }, true, function() { alert('привет'); } ];

// получить элемент с индексом 1 (объект) и затем показать его свойство
alert( arr[1].name ); // Джон

// получить элемент с индексом 3 (функция) и выполнить её
arr[3](); // привет</pre><br><br>
<h3>Получение последних элементов при помощи «at»</h3><br>
<br>
Допустим, нам нужен последний элемент массива.</br></br>

Некоторые языки программирования позволяют использовать отрицательные индексы для той же цели, как-то так: fruits[-1].
<br></br>
Однако, в JavaScript такая запись не сработает. Её результатом будет undefined, поскольку индекс в квадратных скобках понимается буквально.
</br></br>
Мы можем явно вычислить индекс последнего элемента, а затем получить к нему доступ вот так: fruits[fruits.length - 1].
<br></br>
<pre>
let fruits = ["Apple", "Orange", "Plum"];
alert( fruits[fruits.length-1] ); // Plum
</pre><br><br>
Немного громоздко, не так ли? Нам нужно дважды написать имя переменной.<br>

К счастью, есть более короткий синтаксис: fruits.at(-1):<br>
<pre>

let fruits = ["Apple", "Orange", "Plum"];
// то же самое, что и fruits[fruits.length-1]
alert( fruits.at(-1) ); // Plum
</pre><br>
Другими словами, arr.at(i):<br><br>

это ровно то же самое, что и arr[i], если i >= 0.
для отрицательных значений i, он отступает от конца массива.
<h3>Методы pop/push, shift/unshift</h3><br>
Очередь – один из самых распространённых вариантов применения массива. В области компьютерных наук так называется упорядоченная коллекция элементов, поддерживающая два вида операций:
<br>
push добавляет элемент в конец.<br>
shift удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым.
<br>
Массивы поддерживают обе операции

На практике необходимость в этом возникает очень часто. Например, очередь сообщений, которые надо показать на экране.

Существует и другой вариант применения для массивов – структура данных, называемая стек.

Она поддерживает два вида операций:

push добавляет элемент в конец.
pop удаляет последний элемент.
Таким образом, новые элементы всегда добавляются или удаляются из «конца».

Примером стека обычно служит колода карт: новые карты кладутся наверх и берутся тоже сверху:


Массивы в JavaScript могут работать и как очередь, и как стек. Мы можем добавлять/удалять элементы как в начало, так и в конец массива.

В компьютерных науках структура данных, делающая это возможным, называется двусторонняя очередь.

Методы, работающие с концом массива:

pop
Удаляет последний элемент из массива и возвращает его:
<pre>
let fruits = ["Яблоко", "Апельсин", "Груша"];

alert( fruits.pop() ); // удаляем "Груша" и выводим его

alert( fruits ); // Яблоко, Апельсин
</pre>
И fruits.pop() и fruits.at(-1) возвращают последний элемент массива, но fruits.pop() также изменяет массив, удаляя его.
<br>
push
Добавляет элемент в конец массива:<br>
<pre>
let fruits = ["Яблоко", "Апельсин"];

fruits.push("Груша");

alert( fruits ); // Яблоко, Апельсин, Груша</pre><br>
Вызов fruits.push(...) равнозначен fruits[fruits.length] = ....
<br>
Методы, работающие с началом массива:
<br>
shift<br>
Удаляет из массива первый элемент и возвращает его:<br>
<pre>
let fruits = ["Яблоко", "Апельсин", "Груша"];

alert( fruits.shift() ); // удаляем Яблоко и выводим его

alert( fruits ); // Апельсин, Груша
</pre><br>
unshift<br>
Добавляет элемент в начало массива:<br>
<pre>
let fruits = ["Апельсин", "Груша"];

fruits.unshift('Яблоко');

alert( fruits ); // Яблоко, Апельсин, Груша
</pre><br>
Методы push и unshift могут добавлять сразу несколько элементов:
<pre>

let fruits = ["Яблоко"];

fruits.push("Апельсин", "Груша");
fruits.unshift("Ананас", "Лимон");

// ["Ананас", "Лимон", "Яблоко", "Апельсин", "Груша"]
alert( fruits );</pre><br>
<h3>Внутреннее устройство массива</h3><br>
Массив – это особый подвид объектов. Квадратные скобки, используемые для того, чтобы получить доступ к свойству arr[0] – это по сути обычный синтаксис доступа по ключу, как obj[key], где в роли obj у нас arr, а в качестве ключа – числовой индекс.
<br>
Массивы расширяют объекты, так как предусматривают специальные методы для работы с упорядоченными коллекциями данных, а также свойство length. Но в основе всё равно лежит объект.
<br>
Следует помнить, что в JavaScript существует 8 основных типов данных. Массив является объектом и, следовательно, ведёт себя как объект.
<br>
Например, копируется по ссылке:<br>
<pre>
let fruits = ["Банан"]

let arr = fruits; // копируется по ссылке (две переменные ссылаются на один и тот же массив)

alert( arr === fruits ); // true

arr.push("Груша"); // массив меняется по ссылке

alert( fruits ); // Банан, Груша - теперь два элемента
</pre><br>
…Но то, что действительно делает массивы особенными – это их внутреннее представление. Движок JavaScript старается хранить элементы массива в непрерывной области памяти, один за другим, так, как это показано на иллюстрациях к этой главе. Существуют и другие способы оптимизации, благодаря которым массивы работают очень быстро.
<br>
Но все они утратят эффективность, если мы перестанем работать с массивом как с «упорядоченной коллекцией данных» и начнём использовать его как обычный объект.
<br>
Например, технически мы можем сделать следующее:
<br><pre>
let fruits = []; // создаём массив

fruits[99999] = 5; // создаём свойство с индексом, намного превышающим длину массива

fruits.age = 25; // создаём свойство с произвольным именем
</pre><br>
Это возможно, потому что в основе массива лежит объект. Мы можем присвоить ему любые свойства.
<br>
Но движок поймёт, что мы работаем с массивом, как с обычным объектом. Способы оптимизации, используемые для массивов, в этом случае не подходят, поэтому они будут отключены и никакой выгоды не принесут.
<br>
Варианты неправильного применения массива:
<br>
Добавление нечислового свойства, например: arr.test = 5.<br>
Создание «дыр», например: добавление arr[0], затем arr[1000] (между ними ничего нет).<br>
Заполнение массива в обратном порядке, например: arr[1000], arr[999] и т.д.<br>
Массив следует считать особой структурой, позволяющей работать с упорядоченными данными. Для этого массивы предоставляют специальные методы. Массивы тщательно настроены в движках JavaScript для работы с однотипными упорядоченными данными, поэтому, пожалуйста, используйте их именно в таких случаях. Если вам нужны произвольные ключи, вполне возможно, лучше подойдёт обычный объект {}.<br>
`

}